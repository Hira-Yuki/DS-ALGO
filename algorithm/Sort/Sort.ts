/*
  # 알고리즘
  ## 정렬 알고리즘
  정렬은 데이터를 특정 순서로 정렬하는 프로세스이다.
  버블 정렬, 삽입 정렬, 선택 정렬, 퀵 정렬, 병합 정렬, 힙 정렬 등 다양한 정렬 알고리즘을 사용할 수 있다.
*/

/* 
  ### 버블 정렬
  버블 정렬은 리스트를 반복적으로 통과하면서 인접한 요소를 비교하고 순서가 잘못된 경우 교체하는 간단한 정렬 알고리즘이다.
  리스트가 정렬될 때까지 리스트를 통과하는 과정이 반복된다.
  버블 정렬 알고리즘의 시간복잡도는 O(n^2)이다. (평균)

  1. 배열을 처음부터 끝까지 순회하면서 인접한 두 원소를 비교.
  2. 인접한 두 원소가 정렬 순서와 반대인 경우(예를 들어, 앞의 원소가 더 큰 경우)에는 두 원소의 위치를 스왑.
  3. 한 번의 순회를 마치면 가장 큰(또는 작은) 원소가 배열의 맨 끝으로 이동.
  4. 위 과정을 배열의 길이만큼 반복. 각 반복마다 가장 큰(또는 작은) 원소가 정렬된다.
  5. 모든 반복을 마치면 배열이 정렬된다.

  배열의 길이가 크거나 정렬되어야 할 배열이 이미 대부분 정렬되어 있는 경우에도 시간 복잡도가 높아 효율적이지 않음.
  정렬되어야 할 요소가 작고 이미 대부분 정렬되어 있는 경우에는 다른 정렬 알고리즘보다 빠를 수 있음.
*/
const bubbleSort = (arr: number[]): number[] => {
  const len = arr.length

  for (let i = 0; i < len; i++) {
    // 한 번의 순회 동안에는 가장 큰 값이 배열의 끝으로 이동하므로,
    // 배열의 길이에서 i만큼을 빼줍니다.
    for (let j = 0; j < len - 1 - i; j++) {
      // 인접한 두 원소를 비교하여 정렬합니다.
      if (arr[j] > arr[j + 1]) {
        // Swap
        const temp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = temp
      }
    }
  }

  return arr
}

// const array = [64, 25, 12, 22, 11]
// console.log(bubbleSort(array))

/*
  ### 삽입 정렬
  삽입 정렬은 한번에 한 항목씩 최종 정렬된 배열을 구축하는 간단한 정렬 알고리즘이다.
  각 원소를 이미 정렬된 배열 부분에 삽입하면서 정렬을 완성한다.
  삽입 정렬 알고리즘의 시간복잡도는 O(n^2)이다. (최악의 경우) / 최선의 경우는 O(n)이다.

  1. 시작: 주어진 배열의 첫 번째 원소부터 시작.
  2. 정렬된 부분: 배열의 첫 번째 원소는 이미 정렬된 부분.
    따라서 첫 번째 원소를 제외한 나머지 원소는 아직 정렬되지 않은 상태.
  3. 삽입: 두 번째 원소부터 시작하여 현재 원소를 이미 정렬된 부분에 삽입할 위치를 찾음.
    이를 위해 현재 원소보다 큰 원소를 찾을 때까지 이미 정렬된 부분을 순회하며 큰 원소를 한 칸씩 뒤로 이동.
  4. 반복: 모든 원소에 대해 위 과정을 반복. 각 원소를 정렬된 부분에 삽입하면서 정렬이 완성된다.

  - 안정적인 정렬: 동일한 값에 대해서는 원래의 순서를 유지함.
  - 제자리 정렬(In-place Sort): 추가적인 메모리 공간을 필요로하지 않고, 입력 배열 내에서 정렬을 수행함.
  - 비교 횟수: 최선의 경우(이미 정렬되어 있는 경우) O(n)의 시간복잡도이나, 평균 및 최악의 경우에는 O(n^2)의 시간복잡도를 갖지만, 선택 정렬과 버블 정렬에 비해 성능이 우수한 편.
*/

const insertionSort = (arr: number[]): number[] => {
  const len = arr.length

  for (let i = 1; i < len; i++) {
    let j = i - 1
    const key = arr[i]

    // 현재 원소를 이미 정렬된 부분에 삽입할 위치를 찾음
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j]
      j--
    }

    // 삽입할 위치에 현재 원소를 삽입
    arr[j + 1] = key
  }

  return arr
}

// const array = [64, 25, 12, 22, 11]
// console.log(insertionSort(array))

/* 
  ### 퀵 정렬
  분할 및 정복 접근 방식을 사용하는 정렬 알고리즘이다.
  요소를 피벗으로 선택하고 피벗을 중심으로 배열 또는 하위 배열을 분할한 뒤 각 부분을 독립적으로 정렬하는 방식으로 동작한다.

  1. 피벗 선택: 배열에서 하나의 요소를 선택하여 피벗으로 지정. 일반적으로 배열의 첫 번째 요소나 중간 요소를 선택함.
  2. 분할: 피벗을 기준으로 배열을 두 개의 부분으로 분할. 피벗보다 작은 요소는 왼쪽에, 큰 요소는 오른쪽에 위치하도록 함.
  3. 정복: 분할된 각 부분을 재귀적으로 정렬. 이때, 분할된 부분의 크기가 충분히 작아질 때까지 정렬을 수행함.
  4. 결합: 아무 작업을 수행하지 않아도, 분할된 부분이 이미 정렬되어 있으므로 추가적인 작업이 필요하지 않음.

  - 평균 시간 복잡도: O(n log n)
  - 최악 시간 복잡도: O(n^2)
  - 공간 복잡도: 보조 배열 없이 인자 배열 내에서 정렬이 이루어지므로 O(log n)의 공간 복잡도를 가짐.
  - 안정성: 일반적으로 안정성을 보장하지 않음.
  
  퀵 정렬은 일반적으로 대용량 데이터의 정렬에 많이 사용되며, 많은 정렬 라이브러리에서도 퀵 정렬을 기본적으로 사용함.
*/
const quickSort = (arr: number[]): number[] => {
  const len = arr.length

  // 배열의 길이가 1 이하인 경우에는 그대로 반환
  if (len <= 0) return arr
  else {
    // 배열의 첫 번째 요소를 피벗으로 선택
    const pivot = arr[0]
    const left: number[] = []
    const right: number[] = []

    // 피벗을 기준으로 왼쪽과 오른쪽 부분 배열을 분할
    for (let i = 1; i < len; i++) {
      if (arr[i] < pivot) {
        left.push(arr[i])
      } else {
        right.push(arr[i])
      }
    }

    // 왼쪽과 오른쪽 부분 배열을 각각 재귀적으로 정렬하고, 피벗과 결합하여 반환
    return [...quickSort(left), pivot, ...quickSort(right)]
  }
}

const array = [64, 25, 12, 22, 11]
console.log(quickSort(array))
